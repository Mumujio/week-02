# ES6笔记
## let和const命令
### let命令
* 只在let命令所在的代码块内有效。

* for循环的计数器，就很合适使用let命令

* for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域

* 不存在变量提升：var会发生变量提升，let和const不会（let声明的变量一定要在声明后使用)

* 暂时性死区：let声明的变量“绑定”在这个区域，不再受外部影响
   * 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错(在let命令声明变量tmp之前，都属于变量tmp的“死区”)

* let不允许在相同作用域内，重复声明同一个变量。

* 块级作用域的作用：
   1. 防止内层变量覆盖外层变量
   2. 防止用来计数的变量泄露为全局变量
   3. 内层作用域可以定义外层作用域的同名变量

* 在块级作用域中应写成函数表达式

* 函数只能声明在当前作用域的顶层

### const命令
* 声明一个只读的常量，不可改变
* 一旦声明变量就必须初始化
* const作用域与let命令相同，有块级作用域
* 变量的值可变动，变量指向的内存地址保存的数据不可改变
* 对象冻结，应该使用Object.freeze方法

### 顶层对象
* 在浏览器环境指的是window对象，在 Node 指的是global对象（与全局变量等价）
* var命令和function命令声明的全局变量，是顶层对象的属性
* let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性
* 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined
* ES2020，引入globalThis作为顶层对象。即任何环境下，globalThis都是存在的

## 变量的解构赋值
### 数组的解构赋值
* 解构：从数组和对象中提取值，对变量进行赋值
* 如果解构不成功，变量的值就等于undefined。
* 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值
* 数组的解构也可以指定默认值
* 只有当一个数组成员严格等于（===）undefined，默认值才会生效

### 对象的解构赋值
* 而对象的属性没有次序，变量必须与属性同名，才能取到正确的值
* 可以将现有对象的方法，赋值到某个变量
* 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量
* 对象的解构赋值可以取到继承的属性
* 对象的解构也可以指定默认值，默认值生效的条件是，对象的属性值严格等于undefined
* 如果将已经声明的变量用于解构赋值，必须要使用小括号
* 可以对数组进行对象属性的解构

### 字符串的解构赋值
* 字符串被转换成了一个类似数组的对象

### 数值和布尔值的解构赋值
* 只要等号右边的值不是对象或数组，就先将其转为对象

### 函数参数的解构赋值
* 函数参数的解构也可以使用默认值

* 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。

### 变量的解构赋值的用途
1. 交换变量的值
2. 从函数返回多个值
3. 解构赋值可以方便地将一组参数与变量名对应起来。
4. 提取 JSON 数据
5. 可指定参数的默认值
6. 遍历Map结构
7. 输入模块的指定方法
## 字符串和正则表达式
### UTF-16码位
* 字符的数值或码位称之为字符编码

### codePointAt()方法
* 接受：编码单元的位置
* 返回：字符串给定位置对应的码位（整数）
* 作用：检测一个字符占用的编码单元数量

### String.fromCodePoint()方法
* 接受：码位
* 返回：指定码位对应的一个字符
* 作用：码位转换为字符

### normalize()方法
* 接受：一个可选的字符串参数
* 作用：开发国际化应用

### 正则表达式
* 定义：正则表达式是由一个字符序列形成的搜索模式
* 语法：/正则表达式主体/修饰符(可选)     
![](D:\Geek\photo\1.png)

* 作用：
   * search()方法：检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置
   * replace()方法：在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串
   * test()方法：检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。
   * exec()方法：检索字符串中的正则表达式的匹配，返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null

### 正则表达式u修饰符
* 作用：
   1. 从编码单元操作模式切换为字符模式
   2. 计算码位数量
   3. 检测u修饰符支持

### 其他字符串的变更
#### 字符串中的字串识别
* includes()方法：在字符串中检测到指定文本返回true,否则false
* starsWith()方法：在字符串起始部分检测到指定文本返回true,否则false
* endsWith()方法：在字符串结束部分检测到指定文本返回true,否则false
* repeat()方法：字符串重复一定次数

### 其他正则表达式语法变更
#### 正则表达式y修饰符（粘性匹配）
1. 定义：通知搜索从正则表达式的lastIndex属性开始
2. 与g修饰符
* 相同点：与g修饰符一样，保存lastIndex属性（记录匹配字符串最后的位置）的值
* 不同点：g修饰符全局匹配，lastIndex位置往后继续匹配，y修饰符开始遇到不匹配立即停止匹配
3. 只有调用exec()和test()方法才会涉及lastIndex属性，math()不会触发
4. 如果sticky属性的值为true为支持y修饰符，否则为false。只可读属性。

#### 正则表达式的复制
* 可以通过给RegExp构造函数传递正则表达式作为参数来复制这个正则表达式
var re1 = /ab/i,
      re2 = new RegExg(re1);
* 可以为正则表达式指定一个修饰符（ES6)
var re1 = /ab/i,
      re2 = new RegExp(re1,"g");

#### flags属性和source属性
* flags属性：会返回所有应用于当前正则表达式的修饰符字符串
* source属性：获取正则表达式的文本
* 注意：以上两个属性均为只读

#### 模板字面量
* 意义：
   1. 一个正式的多行字符串的概念
   2. 将变量嵌入字符串的能力
   3. 向HTML插入经过安全转换后的字符串的能力
* 基础语法：使用 ` 代替 " 。字符串中再想使用 ` 的话，加上\转义，"和'则不需要转义。
* 作用：
   1. 简化多行字符串：可直接回车换行（反撇号中，空白符也属于字符串的一部分）
   2. `字符串占位符`：
      * 组成：${   }   中间可包含任意表达式（已定义）
      * 功能：可以把任何表达式嵌入到占位符中作为字符串的一部分
      * 注意：模板字面量可嵌套
   3. `标签模板（不太懂）`：
      * 定义：在第一个反撇号前标注字符串
      * 在模板字符量中使用原始值
         * string.raw()标签：检测转义前的模板字符串

## 函数
### 函数形参的默认值

#### ES6中的默认参数值
* 可在函数定义括号中为参数指定任意默认值。
* 参数传入为undifine时使用默认值，传入null则不使用默认值，其值最终也为null

#### 默认参数值对arguments对象的影响
* 默认参数值的存在使得arguments对象保持与命名参数分离。（总是可以通过arguments对象将参数恢复为初始值）

#### 默认参数表达式
* 初次解析函数声明时不会调用默认函数参数。默认参数是在函数调用时的求值。
* 在引用参数默认值时，只允许引用前面参数的值。先定义能访问后定义的参数。

#### 默认参数的死区
* 与let相似，函数参数未初始化之前会进入临时死区，引用会报错
* 函数参数有自己的作用域和临时死区，不可访问函数体内声明的变量

### 处理无命名的参数
#### 不定参数
* 形式：在命名参数前加三个点（.）。该参数为一个数组，`包含了自它之后传入的所有参数`
* arguments对象包含的则是所有传入的参数
* 使用限制：
   1. 每个函数只能声明一个不定参数，并且一定要放在所有参数的末尾
   2. 不定参数不能用于对象字面量setter之中
* 无论是否使用不定参数，arguments对象总是包含所有传入函数的参数

#### 增强的Function 构造函数、
* 支持在创建函数时定义参数和不定参数
* 定义不定参数只需在最后一个参数前添加（...)

#### 展开运算符
* Math.max()方法：接受任意数量参数，返回最大值。不允许传入数组。在数组前使用(...)符号，可以实现传入数组

### name属性
* name属性值为函数声明时的函数名称 （例如：fuction dosomething (){} )  name = "dosomething"
* 匿名函数表达式的name属性值为被匿名函数赋值的变量的名称 （例如：var Dosomething = fuction (){} )   name = "Dosomething"
#### name属性的特殊情况
* 函数表达式本身名字的权重比被该函数赋值的函数的名字高 （ var A = fuction B() {} ) A.name = "B")
* 不能使用name属性的值来获取对于函数的引用

#### 函数的多重用途
* js函数的两个不同的内部方法：[[Call]] 和 [[Construct]]
   1. 执行[[Call]]方法： 通过new关键字调用函数时。（创建称为实例的新对象->执行函数体->this绑定到实例上）（被称为构造函数）
   2. 执行[[construct]]方法：不通过new关键字调用函数时。 （直接执行函数体）

### 箭头函数
* ES6 允许使用“箭头”（=>）定义函数。
var f = v => v;
// 等同于
var f = function (v) {
  return v;
};

* 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回
var sum = (num1, num2) => { return num1 + num2; }

* 箭头函数的一个用处是简化回调函数

### 尾调用
* 指某个函数的最后一步是调用另一个函数
* 尾递归：对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

### 函数参数的尾逗号

### Function.prototype.toString()
* 修改后的toString()方法，明确要求返回一模一样的原始代码
function /* foo comment */ foo () {}
foo.toString()
// "function /* foo comment */ foo () {}"

### catch 命令的参数省略
* try...catch结构，允许catch语句省略参数
## 数值的拓展
### 二进制和八进制表示法
* ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示
* 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法

### 数值分隔符
* 数值分隔符没有指定间隔的位数可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个

### Number.isFinite(), Number.isNaN()
* Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity
* Number.isNaN()用来检查一个值是否为NaN

### Number.isNaN()用来检查一个值是否为NaN
* ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变

### Number.isInteger()
* Number.isInteger()用来判断一个数值是否为整数

### Number.EPSILON()
* 它表示 1 与大于 1 的最小浮点数之间的差

### 安全整数和 Number.isSafeInteger()

### Math 对象的扩展
1. Math.trunc()
   * Math.trunc方法用于去除一个数的小数部分，返回整数部分。
2. Math.sign()
   * Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值
3. Math.cbrt()
   * Math.cbrt()方法用于计算一个数的立方根。
4. Math.clz32()
   * Math.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0
5. Math.imul()
   * Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数
6. Math.fround()
   * Math.fround方法返回一个数的32位单精度浮点数形式
7. Math.hypot()
   * Math.hypot方法返回所有参数的平方和的平方根
8. Math.expm1()
   * Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1
9. Math.log1p()
   * Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN
10. Math.log10()
   * Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN
11. Math.log2()
   * Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN

### BigInt 数据类型
* 为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n
* BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示

### BigInt 函数
* 可以用它生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt
* 可以使用Boolean()、Number()和String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型
* BigInt 对应的布尔值，与 Number 类型一致，即0n会转为false，其他值转为true

## Symbol
* 表示独一无二的值。它是 JavaScript 语言的第七种数据类型
### Symbol.prototype.description
* 直接返回 Symbol 的描述
### Object.getOwnPropertySymbols()
* 可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值
### Reflect.ownKeys()
* 可以返回所有类型的键名，包括常规键名和 Symbol 键名
### Symbol.for()
* 重新使用同一个 Symbol 值
* Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会
### Symbol.keyFor()
* 方法返回一个已登记的 Symbol 类型值的key
### 模块的 Singleton 模式
### 内置的 Symbol 值
* 共有12个
## Set 和 Map 数据结构
* 它类似于数组，但是成员的值都是唯一的，没有重复的值
* Set本身是一个构造函数，用来生成 Set 数据结构
### WeakSet
* WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别:
   1. WeakSet 的成员只能是对象，而不能是其他类型的值
   2. WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用
* WeakSet 是一个构造函数，可以使用new命令，创建 WeakSet 数据结构
### Map
* 它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键
### WeakMap
* WeakMap结构与Map结构类似，也是用于生成键值对的集合,有两个区别：
   1. WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名
   2. WeakMap的键名所指向的对象，不计入垃圾回收机制
### WeakRef
* 用于直接创建对象的弱引用
### FinalizationRegistry
* 用来指定目标对象被垃圾回收机制清除以后，所要执行的回调函数
## Proxy（代理器）
* Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程
## Reflect
* 目的： ES6 为了操作对象而提供的新 API
   1.  将Object对象的一些明显属于语言内部的方法放到Reflect对象上
   2.  修改某些Object方法的返回结果，让其变得更合理
   3.  让Object操作都变成函数行为。某些Object操作是命令式
   4.  Reflect对象的方法与Proxy对象的方法一一对应

## Promise 对象
* 从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理
## Iterator 和 for...of 循环
### Iterator（遍历器）的概念
* 它是一种接口，为各种不同的数据结构提供统一的访问机制
* 作用：
   1. 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象
   2. 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员
   3. 第二次调用指针对象的next方法，指针就指向数据结构的第二个成员
   4. 不断调用指针对象的next方法，直到它指向数据结构的结束位置
### for...of 循环
* 遍历所有数据结构的统一的方法
*  一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法
## Generator 函数的语法
* Generator 函数是 ES6 提供的一种异步编程解决方案
* Generator 可以暂停函数执行，返回任意表达式的值
* 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态
## async 函数
* 它就是 Generator 函数的语法糖
## Class 的基本语法(类）
* 作为对象的模板。通过class关键字，可以定义类
## Module 的语法
* 浏览器和服务器通用的模块解决方案

## 编程风格
### 块级作用域
1. let 取代 var：var有变量提升
2. 全局常量和线程安全：在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量
   * 所有的函数都应该设置为常量
### 字符串
* 静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号
### 解构赋值
1. 使用数组成员对变量赋值时，优先使用解构赋值
2. 函数的参数如果是对象的成员，优先使用解构赋值
3. 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序
### 对象
1. 单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾
2. 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法
3. 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义
### 数组
1. 使用扩展运算符（...）拷贝数组
2. 使用 Array.from 方法，将类似数组的对象转为数组
### 函数
1. 立即执行函数可以写成箭头函数的形式
2. 那些使用匿名函数当作参数的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了 this
3. 箭头函数取代Function.prototype.bind，不应再用 self/_this/that 绑定 this
4. 简单的、单行的、不会复用的函数，建议采用箭头函数
5. 不要在函数体内使用 arguments 变量，使用 rest 运算符（...）代替
6. 使用默认值语法设置函数参数的默认值
### Map结构
* 只有模拟现实世界的实体对象时，才使用 Object。如果只是需要key: value的数据结构，使用 Map 结构。因为 Map 有内建的遍历机制
### Class
* 总是用 Class，取代需要 prototype 的操作
* 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险
### 模块
* ES6 模块语法是 JavaScript 模块的标准写法，坚持使用这种写法，取代 Node.js 的 CommonJS 语法
1. 使用import取代require()
2. 使用export取代module.exports
### ESLint 的使用
* ESLint 是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码


















































