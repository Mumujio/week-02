# ES6笔记
## let和const命令
### let命令
* 只在let命令所在的代码块内有效。

* for循环的计数器，就很合适使用let命令

* for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域

* 不存在变量提升：var会发生变量提升，let和const不会（let声明的变量一定要在声明后使用)

* 暂时性死区：let声明的变量“绑定”在这个区域，不再受外部影响
   * 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错(在let命令声明变量tmp之前，都属于变量tmp的“死区”)

* let不允许在相同作用域内，重复声明同一个变量。

* 块级作用域的作用：
   1. 防止内层变量覆盖外层变量
   2. 防止用来计数的变量泄露为全局变量
   3. 内层作用域可以定义外层作用域的同名变量

* 在块级作用域中应写成函数表达式

* 函数只能声明在当前作用域的顶层

### const命令
* 声明一个只读的常量，不可改变
* 一旦声明变量就必须初始化
* const作用域与let命令相同，有块级作用域
* 变量的值可变动，变量指向的内存地址保存的数据不可改变
* 对象冻结，应该使用Object.freeze方法

### 顶层对象
* 在浏览器环境指的是window对象，在 Node 指的是global对象（与全局变量等价）
* var命令和function命令声明的全局变量，是顶层对象的属性
* let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性
* 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined
* ES2020，引入globalThis作为顶层对象。即任何环境下，globalThis都是存在的

## 变量的解构赋值
### 数组的解构赋值
* 解构：从数组和对象中提取值，对变量进行赋值
* 如果解构不成功，变量的值就等于undefined。
* 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值
* 数组的解构也可以指定默认值
* 只有当一个数组成员严格等于（===）undefined，默认值才会生效

### 对象的解构赋值
* 而对象的属性没有次序，变量必须与属性同名，才能取到正确的值
* 可以将现有对象的方法，赋值到某个变量
* 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量
* 对象的解构赋值可以取到继承的属性
* 对象的解构也可以指定默认值，默认值生效的条件是，对象的属性值严格等于undefined
* 如果将已经声明的变量用于解构赋值，必须要使用小括号
* 可以对数组进行对象属性的解构

### 字符串的解构赋值
* 字符串被转换成了一个类似数组的对象

### 数值和布尔值的解构赋值
* 只要等号右边的值不是对象或数组，就先将其转为对象

### 函数参数的解构赋值
* 函数参数的解构也可以使用默认值

* 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。

### 变量的解构赋值的用途
1. 交换变量的值
2. 从函数返回多个值
3. 解构赋值可以方便地将一组参数与变量名对应起来。
4. 提取 JSON 数据
5. 可指定参数的默认值
6. 遍历Map结构
7. 输入模块的指定方法
## 字符串和正则表达式
### UTF-16码位
* 字符的数值或码位称之为字符编码

### codePointAt()方法
* 接受：编码单元的位置
* 返回：字符串给定位置对应的码位（整数）
* 作用：检测一个字符占用的编码单元数量

### String.fromCodePoint()方法
* 接受：码位
* 返回：指定码位对应的一个字符
* 作用：码位转换为字符

### normalize()方法
* 接受：一个可选的字符串参数
* 作用：开发国际化应用

### 正则表达式
* 定义：正则表达式是由一个字符序列形成的搜索模式
* 语法：/正则表达式主体/修饰符(可选)     
![](D:\Geek\photo\1.png)

* 作用：
   * search()方法：检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置
   * replace()方法：在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串
   * test()方法：检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。
   * exec()方法：检索字符串中的正则表达式的匹配，返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null

### 正则表达式u修饰符
* 作用：
   1. 从编码单元操作模式切换为字符模式
   2. 计算码位数量
   3. 检测u修饰符支持

### 其他字符串的变更
#### 字符串中的字串识别
* includes()方法：在字符串中检测到指定文本返回true,否则false
* starsWith()方法：在字符串起始部分检测到指定文本返回true,否则false
* endsWith()方法：在字符串结束部分检测到指定文本返回true,否则false
* repeat()方法：字符串重复一定次数

### 其他正则表达式语法变更
#### 正则表达式y修饰符（粘性匹配）
1. 定义：通知搜索从正则表达式的lastIndex属性开始
2. 与g修饰符
* 相同点：与g修饰符一样，保存lastIndex属性（记录匹配字符串最后的位置）的值
* 不同点：g修饰符全局匹配，lastIndex位置往后继续匹配，y修饰符开始遇到不匹配立即停止匹配
3. 只有调用exec()和test()方法才会涉及lastIndex属性，math()不会触发
4. 如果sticky属性的值为true为支持y修饰符，否则为false。只可读属性。

#### 正则表达式的复制
* 可以通过给RegExp构造函数传递正则表达式作为参数来复制这个正则表达式
var re1 = /ab/i,
      re2 = new RegExg(re1);
* 可以为正则表达式指定一个修饰符（ES6)
var re1 = /ab/i,
      re2 = new RegExp(re1,"g");

#### flags属性和source属性
* flags属性：会返回所有应用于当前正则表达式的修饰符字符串
* source属性：获取正则表达式的文本
* 注意：以上两个属性均为只读

#### 模板字面量
* 意义：
   1. 一个正式的多行字符串的概念
   2. 将变量嵌入字符串的能力
   3. 向HTML插入经过安全转换后的字符串的能力
* 基础语法：使用 ` 代替 " 。字符串中再想使用 ` 的话，加上\转义，"和'则不需要转义。
* 作用：
   1. 简化多行字符串：可直接回车换行（反撇号中，空白符也属于字符串的一部分）
   2. `字符串占位符`：
      * 组成：${   }   中间可包含任意表达式（已定义）
      * 功能：可以把任何表达式嵌入到占位符中作为字符串的一部分
      * 注意：模板字面量可嵌套
   3. `标签模板（不太懂）`：
      * 定义：在第一个反撇号前标注字符串
      * 在模板字符量中使用原始值
         * string.raw()标签：检测转义前的模板字符串

## 函数
### 函数形参的默认值

#### ES6中的默认参数值
* 可在函数定义括号中为参数指定任意默认值。
* 参数传入为undifine时使用默认值，传入null则不使用默认值，其值最终也为null

#### 默认参数值对arguments对象的影响
* 默认参数值的存在使得arguments对象保持与命名参数分离。（总是可以通过arguments对象将参数恢复为初始值）

#### 默认参数表达式
* 初次解析函数声明时不会调用默认函数参数。默认参数是在函数调用时的求值。
* 在引用参数默认值时，只允许引用前面参数的值。先定义能访问后定义的参数。

#### 默认参数的死区
* 与let相似，函数参数未初始化之前会进入临时死区，引用会报错
* 函数参数有自己的作用域和临时死区，不可访问函数体内声明的变量

### 处理无命名的参数
#### 不定参数
* 形式：在命名参数前加三个点（.）。该参数为一个数组，`包含了自它之后传入的所有参数`
* arguments对象包含的则是所有传入的参数
* 使用限制：
   1. 每个函数只能声明一个不定参数，并且一定要放在所有参数的末尾
   2. 不定参数不能用于对象字面量setter之中
* 无论是否使用不定参数，arguments对象总是包含所有传入函数的参数

#### 增强的Function 构造函数、
* 支持在创建函数时定义参数和不定参数
* 定义不定参数只需在最后一个参数前添加（...)

#### 展开运算符
* Math.max()方法：接受任意数量参数，返回最大值。不允许传入数组。在数组前使用(...)符号，可以实现传入数组

### name属性
* name属性值为函数声明时的函数名称 （例如：fuction dosomething (){} )  name = "dosomething"
* 匿名函数表达式的name属性值为被匿名函数赋值的变量的名称 （例如：var Dosomething = fuction (){} )   name = "Dosomething"
#### name属性的特殊情况
* 函数表达式本身名字的权重比被该函数赋值的函数的名字高 （ var A = fuction B() {} ) A.name = "B")
* 不能使用name属性的值来获取对于函数的引用

#### 函数的多重用途
* js函数的两个不同的内部方法：[[Call]] 和 [[Construct]]
   1. 执行[[Call]]方法： 通过new关键字调用函数时。（创建称为实例的新对象->执行函数体->this绑定到实例上）（被称为构造函数）
   2. 执行[[construct]]方法：不通过new关键字调用函数时。 （直接执行函数体）

### 箭头函数
* ES6 允许使用“箭头”（=>）定义函数。
var f = v => v;
// 等同于
var f = function (v) {
  return v;
};

* 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回
var sum = (num1, num2) => { return num1 + num2; }

* 箭头函数的一个用处是简化回调函数

### 尾调用
* 指某个函数的最后一步是调用另一个函数
* 尾递归：对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

### 函数参数的尾逗号

### Function.prototype.toString()
* 修改后的toString()方法，明确要求返回一模一样的原始代码
function /* foo comment */ foo () {}
foo.toString()
// "function /* foo comment */ foo () {}"

### catch 命令的参数省略
* try...catch结构，允许catch语句省略参数
## 数值的拓展
### 二进制和八进制表示法
* ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示
* 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法

### 数值分隔符
* 数值分隔符没有指定间隔的位数可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个

### Number.isFinite(), Number.isNaN()
* Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity
* Number.isNaN()用来检查一个值是否为NaN

### Number.isNaN()用来检查一个值是否为NaN
* ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变

### Number.isInteger()
* Number.isInteger()用来判断一个数值是否为整数

### Number.EPSILON()
* 它表示 1 与大于 1 的最小浮点数之间的差

### 安全整数和 Number.isSafeInteger()

### Math 对象的扩展
1. Math.trunc()
   * Math.trunc方法用于去除一个数的小数部分，返回整数部分。
2. Math.sign()
   * Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值
3. Math.cbrt()
   * Math.cbrt()方法用于计算一个数的立方根。
4. Math.clz32()
   * Math.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0
5. Math.imul()
   * Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数
6. Math.fround()
   * Math.fround方法返回一个数的32位单精度浮点数形式
7. Math.hypot()
   * Math.hypot方法返回所有参数的平方和的平方根
8. Math.expm1()
   * Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1
9. Math.log1p()
   * Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN
10. Math.log10()
   * Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN
11. Math.log2()
   * Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN

### BigInt 数据类型
* 为了与 Number 类型区别，BigInt 类型的数据必须添加后缀n
* BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示

### BigInt 函数
* 可以用它生成 BigInt 类型的数值。转换规则基本与Number()一致，将其他类型的值转为 BigInt
* 可以使用Boolean()、Number()和String()这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型
* BigInt 对应的布尔值，与 Number 类型一致，即0n会转为false，其他值转为true

## Symbol
* 表示独一无二的值。它是 JavaScript 语言的第七种数据类型














































