# ES6笔记
## let和const命令
### let命令
* 只在let命令所在的代码块内有效。

* for循环的计数器，就很合适使用let命令

* for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域

* 不存在变量提升：var会发生变量提升，let和const不会（let声明的变量一定要在声明后使用)

* 暂时性死区：let声明的变量“绑定”在这个区域，不再受外部影响
   * 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错(在let命令声明变量tmp之前，都属于变量tmp的“死区”)

* let不允许在相同作用域内，重复声明同一个变量。

* 块级作用域的作用：
   1. 防止内层变量覆盖外层变量
   2. 防止用来计数的变量泄露为全局变量
   3. 内层作用域可以定义外层作用域的同名变量

* 在块级作用域中应写成函数表达式

* 函数只能声明在当前作用域的顶层

### const命令
* 声明一个只读的常量，不可改变
* 一旦声明变量就必须初始化
* const作用域与let命令相同，有块级作用域
* 变量的值可变动，变量指向的内存地址保存的数据不可改变
* 对象冻结，应该使用Object.freeze方法

### 顶层对象
* 在浏览器环境指的是window对象，在 Node 指的是global对象（与全局变量等价）
* var命令和function命令声明的全局变量，是顶层对象的属性
* let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性
* 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined
* ES2020，引入globalThis作为顶层对象。即任何环境下，globalThis都是存在的

## 变量的解构赋值
### 数组的解构赋值
* 解构：从数组和对象中提取值，对变量进行赋值
* 如果解构不成功，变量的值就等于undefined。
* 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值
* 数组的解构也可以指定默认值
* 只有当一个数组成员严格等于（===）undefined，默认值才会生效

### 对象的解构赋值
* 而对象的属性没有次序，变量必须与属性同名，才能取到正确的值
* 可以将现有对象的方法，赋值到某个变量
* 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量
* 对象的解构赋值可以取到继承的属性
* 对象的解构也可以指定默认值，默认值生效的条件是，对象的属性值严格等于undefined
* 如果将已经声明的变量用于解构赋值，必须要使用小括号
* 可以对数组进行对象属性的解构

### 字符串的解构赋值
* 字符串被转换成了一个类似数组的对象

### 数值和布尔值的解构赋值
* 只要等号右边的值不是对象或数组，就先将其转为对象

### 函数参数的解构赋值
* 函数参数的解构也可以使用默认值

* 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。

### 变量的解构赋值的用途
1. 交换变量的值
2. 从函数返回多个值
3. 解构赋值可以方便地将一组参数与变量名对应起来。
4. 提取 JSON 数据
5. 可指定参数的默认值
6. 遍历Map结构
7. 输入模块的指定方法
















