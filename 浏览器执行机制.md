# 浏览器的运行机制详解
## 进程与线程
### 进程与线程基本概念
1. 进程->工厂 （有系统分配的独立的资源；相互独立，无法读到对方内存中的数据）
2. 线程->工人 （协同；信息互通）
3. 一个进程中有多个进程；系统以线程为单位分配cpu中的核；系统以进程为最小单位分配内存空间；进程之间也能互相通信，不过代价比较大
###  浏览器的进程
1. Browser进程（ 是浏览器的主进程，负责主控，协调，只有一个，可以看做是浏览器的大脑）
   1.  负责下载页面的网络文件
   2.  负责将renderer进程得到的存在内存中的位图渲染（显示）到页面上
   3.  负责创建和销毁tab进程（renderer进程）
   4.  **负责与用户的交互**
2.  GPU进程（只有一个）
   1.  负责3D绘制。只有当该页面使用了硬件加速才会使用它，来渲染（显示）页面，否则的话，不使用这个进程，而是用Browser进程来渲染（显示）页面
3.  renderer进程 （又名**浏览器内核**，**每个tab页面对应一个独立的renderer进程**。多线程）
   1.  **负责脚本执行**，位图绘制，事件触发，任务队列轮询等
   2.  第三方插件进程：每种类型的插件对应一个进程
   3.  常驻线程：
      1. **js引擎线程**：也称js内核，解析js脚本，执行代码；与GUI线程互斥，当js引擎线程结束运行时，才会继续运行GUI线程；由一个主线程和多个web worker线程组成 
      2.  GUI渲染线程：**用于解析html为DOM树，解析css为CSSOM树**，布局layout，绘制paint,当页面需要重排reflow，重绘repaint时，使        用该线程
      3.  事件触发线程: 当对应事件触发，该线程会将事件对应的回调函数放入callback queue（任务队列）中，等待js引擎线程的处理
      4.  定时触发线程: 如果该状态变更事件对应有回调函数的话，则放入任务队列中
      5.  任务队列轮询线程: 于轮询监听任务队列，以知道任务队列是否为空
## html的解析
* html解析包含有一系列的步骤，过程为Bytes -> Characters -> Tokens -> Nodes -> DOM。最终将html解析为DOM树。
## css解析
* 他解析最终形成CSSOM树，过程为Bytes -> Characters -> Tokens -> Nodes -> CSSOM
## render树
* 由DOM树与CSS树结合形成的渲染树**（其中无法显示的元素，如script，head元素或diplay：none的元素，不会在渲染树中，也就最终不会被渲染出来）**，页面的布局，绘制都是以render树为依据
## 回流与重绘
* 布局是页面首次加载时进行的操作，*重新布局即为回流*。
* 绘制是页面首次加载时进行的操作，*重新绘制即为重绘*。
* 当页面的某部分元素发生了**尺寸、位置、隐藏发生了改变，页面进行回流**。得对整个页面重新进行布局计算，将所有尺寸，位置受到影响的元素回流。 - 当页面的某部分**元素的外观发生了改变，但尺寸、位置、隐藏没有改变，页面进行重绘**。（同样，只重绘部分元素，而不是整个页面重绘）
* 引起回流的原因：
1. **- 页面初始化渲染 - 窗口的尺寸变化 - 元素的尺寸、位置、隐藏变化 - DOM结构发生变化，如删除节点 - 获取某些属性，引发回流 - 很多浏览器会对回流进行优化，一定时间段后或数量达到阕值时，做一次批处理回流。**
2. **当获取一些属性时，浏览器为了返回正确的值也会触发回流，导致浏览器优化无效，字体大小修改及内容更新也会导致回流。频繁的回流与重绘会导致频繁的页面渲染，导致cpu或gpu过量使用，使得页面卡顿**
* 如何减少回流：
1. 减少逐项更改样式，最好一次性更改style，或是将更改的样式定义在class中并一次性更新
2. 避免循环操作DOM，而是新建一个节点，在他上面应用所有DOM操作，然后再将他接入到DOM中
3. 当要频繁得到如offset属性时，只读取一次然后赋值给变量，而不是每次都获取一次
4. 将复杂的元素绝对定位或固定定位，使他脱离文档流，否则回流代价很高
5. 使用硬件加速创建一个新的复合图层，当其需要回流时不会影响原始复合图层回流
   1. DOM中的每个结点对应一个简单图层 - 复合图层是各个简单图层的合并，一个页面一般来说只有一个复合图层，无论你创建了多少个元素，都    是在这个复合图层中  
   2. 当一个元素使用硬件加速后，会生成一个新的复合图层，这样不管其如何变化，都不会影响原复合图层。不过不要大量使用硬件加速，这样不管其如何变化，都不会影响原复合图层。不过不要大量使用硬件加速，会导致资源消耗过度，导致页面也卡。所以，使用了硬件加速后，会有多个复合图层，然后多个复合图层互相独立，单独布局、绘制
* 如何才能使用硬件加速：
1. translate3d,translateZ
2. opacity属性
**注意：硬件加速时请使用z-index：当一个元素使用了硬件加速，在其后的元素，若z-index比他大或者相同，且absolute或fixed的属性相同，则默认为这些元素也创建各自的复合图层。所以我们人为地为这个元素添加z-index值，从而避免这种情况**
## 浏览器页面的渲染流程
1. 解析html得到DOM树
2. 解析css得到CSS树
3. 合并得到render树
4. 布局，当页面有元素的尺寸、大小、隐藏有变化或增加、删除元素时，重新布局计算，并修改页面中所有受影响的部分
5. 绘制，当页面有元素的外观发生变化时，重新绘制
6. GUI线程将得到的各层的位图（每个元素对应一个普通图层）发送给Browser进程，由Browser进程将各层合并，渲染在页面上

## DOMContentLoaded和load事件
* DOMContentLoaded：当DOM加载完成触发
* load：当DOM，样式表，脚本都加载完时触发

### css的堵塞情况
* 由于css的下载和解析不会影响DOM树，所以不会堵塞html文件的解析，但会堵塞页面渲染。

### js的堵塞情况
* js文件的下载和解析执行都会堵塞html文件的解析及页面渲染。使用async属性，这样就可以异步加载js文件，加载完成后立即执行

### css和js文件应当放在html哪个位置
* 如果js的内容比较小，则推荐使用内部js而不是引用js，这样可以减少http请求。

## 导致页面无法立即响应的原因
* 导致页面无法响应的原因是执行栈中还有任务未执行完，或者是js引擎线程被GUI线程堵塞。

## html文件解析过程
这个过程是在下载html文件之后，不包括网络请求过程

1. Browser进程下载html文件并将文件发送给renderer进程

2. renderer进程的GUI进程开始解析html文件来构建出DOM

3. 当遇到外源css时，Browser进程下载该css文件并发送回来，GUI线程再解析该文件，在这同时，html的解析也同时进行，但不会渲染（还未形成渲染树）

4. 当遇到内部css时，html的解析和css的解析同时进行

5. 继续解析html文件，当遇到外源js时，Browser进程下载该js文件并发送回来，此时，js引擎线程解析并执行js，因为GUI线程和js引擎线程互斥，所以GUI线程被挂起，停止继续解析html。直到js引擎线程空闲，GUI线程继续解析html。

6. 遇到内部js也是同理

7. 解析完html文件，形成了完整的DOM树，也解析完了css，形成了完整的CSSOM树，两者结合形成了render树

8. 根据render树来进行布局，若在布局的过程中发生了元素尺寸、位置、隐藏的变化或增加、删除元素时，则进行回流，修改

9. 根据render树进行绘制，若在布局的过程中元素的外观发生变换，则进行重绘

10. 将布局、绘制得到的各个简单图层的位图发送给Browser进程，由它来合并简单图层为复合图层，从而显示到页面上

11. 以上步骤就是html文件解析全过程，完成之后，如若当页面有元素的尺寸、大小、隐藏有变化时，重新布局计算回流，并修改页面中所有受影响的部分，如若当页面有元素的外观发生变化时，重绘





























